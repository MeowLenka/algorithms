/**
 * Практическое занятие №3. Встроенные массивы. Динамическое выделение памяти.
 * Простейшие алгоритмы сортировки и поиска. Сложные указатели.
 */
#include <iostream>
#include <cstring>

int myrandom(int a, int b)
{
    srand(time(0));
    return rand() % (b - a) + a;
}

int main()
{
    /**
     * Задание 1. Встроенные массивы.
     */

    /**
     * Задание 1.1.
     *
     * Объявите трехмерный N*M*K массив и сформируйте значения
     * элементов, указанные на иллюстрации ниже, с помощью инициализации при
     * объявлении.
     *
     *                   |--------|
     *                 / |3  3  3 |
     *               |---------|3 |
     *             / | 2  2  2 |3 |
     *            |---------|2 |__|
     *            | 1  1  1 |2 | /
     *            | 1  1  1 |__|
     *            | 1  1  1 | /
     *            |_________|
     */
    int alsonumbers[3][3][3] = {
        {{1, 1, 1},
         {1, 1, 1},
         {1, 1, 1}},
        {{2, 2, 2},
         {2, 2, 2},
         {2, 2, 2}},
        {{3, 3, 3},
         {3, 3, 3},
         {3, 3, 3}}};
    /**
     * Задание 1.2.
     *
     * Объявите неинициализированный массив и присвойте значения элементам с
     * помощью кода так, чтобы в итоге получился такой же массив, как в задании
     * 1.1.
     */
    int emptynumbers[3][3][3] = {};
    for (int i = 0; i < 3; i++)
    {
        for (int j = 0; j < 3; j++)
        {
            for (int k = 0; k < 3; k++)
            {
                emptynumbers[i][j][k] = i + 1;
            }
        }
    }
    /**
     * Задание 1.3.
     *
     * Напишите код, с помощью которого можно найти сумму элементов массива,
     * полученного в задании 1.
     */
    int sum = 0;
    for (int i = 0; i < 3; i++)
    {
        for (int j = 0; j < 3; j++)
        {
            for (int k = 0; k < 3; k++)
            {
                sum += alsonumbers[i][j][k];
            }
        }
    }
    /**
     * Задание 1.4.
     *
     * Проинициализируйте массив при объявлении следующим образом:
     *
     *                   |--------|
     *                 / |3  0  0 |
     *               |---------|0 |
     *             / | 2  0  0 |0 |
     *            |---------|0 |__|
     *            | 1  0  0 |0 | /
     *            | 0  0  0 |__|
     *            | 0  0  0 | /
     *            |_________|
     *
     * Как это можно сделать наиболее коротким (в смысле количества кода)
     * образом?
     */
    int zeronumbers[3][3][3] = {
        {1},
        {2},
        {3}};

    /**
     * Задание 1.5. Инициализация массивов строковыми литералами.
     *
     * Объявите и проинициализируйте строковыми литералами два массива:
     * двухмерный массив и массив указателей. Поясните разницу в использовании
     * элементов таких массивов.
     */
    char mas1[][5] = {"hi", "vlad"};
    // у двухмерного массива фиксированный размер для каждой строки, разное использование памяти
    char *mas2[] = {"hi", "my", "best", "friend", "vlad"};
    /**
     * Задание 2. Динамическое выделение памяти.
     */

    /**
     * Задание 2.1.
     *
     * Создайте динамический двухмерный массив с размерностями, вычисляемыми в
     * процессе выполнения программы - N*M, эти размерности можно сформировать
     * случайно в некотором диапазоне или ввести с консоли.
     *
     * Задайте значения элементов помощью генератора случайных чисел.
     *
     * Найдите сумму элементов.
     *
     * Подсказка 1: для генерации случайных чисел используйте функцию
     * стандартной библиотеки - rand() (<cstdlib>).
     *
     * Подсказка 2: На самом деле те значения, которые создаются генератором
     * случайных чисел являются «псевдослучайными», то есть при двух
     * последовательных запусках приложения Вы получаете две одинаковые
     * последовательности значений.
     *
     * Для того чтобы генерируемые "случайные" значения были разными при каждом
     * запуске приложения используйте функции стандартной библиотеки srand()
     * (<cstdlib>) и time() (<ctime>).
     *
     * Функция srand() осуществляет «привязку» начала генерации к указанному в
     * качестве параметра значению.
     *
     * Функция time() задает эту точку отсчета, считывая текущее время.
     */

    int n = myrandom(1, 10), m = myrandom(1, 10);

    int **dinamic = new int *[n];
    for (int i = 0; i < n; i++)
        dinamic[i] = new int[m];

    srand(time(0));
    for (int i = 0; i < n; i++)
        for (int j = 0; j < m; j++)
            dinamic[i][j] = rand() % 100;

    /**
     * Задание 2.2.
     *
     * В сформированном массиве отсортируйте каждую строку по убыванию
     * значений. Используйте сортировку "выбором".
     */
    int minimal = 0, ad = 0;
    for (int st = 0; st < n; st++)
    {
        for (int i = 0; i < m; i++)
        {
            minimal = i;
            for (int j = i + 1; j < m; j++)
            {
                if (dinamic[st][j] < dinamic[st][minimal])
                    minimal = j;
            }
            ad = dinamic[st][minimal];
            dinamic[st][minimal] = dinamic[st][i];
            dinamic[st][i] = ad;
        }
    }
    /**
     * Задание 2.3.
     *
     * Объявите одномерный массив размерностью N.
     *
     * Сформируйте значение i-ого элемента одномерного массива  равным среднему
     * значению элементов i-ой строки двухмерного массива.
     */
    int avg = 0;
    int *masavg = new int[n];

    for (int i = 0; i < n; i++)
    {
        avg = 0;
        for (int j = 0; j < m; j++)
        {
            avg += dinamic[i][j];
            masavg[i] = avg / m;
        }
    }

    /**
     * Задание 2.4.
     *
     * Убедитесь, что вся выделенная память очищена.
     *
     * Чтобы убедиться в этом, скомпилируйте программу с включенной проверкой
     * утечек памяти - с ключом `-fsanitize=address`:
     *
     * `gcc <ваши обычные флаги> -fsanitize=address lab3.cpp`
     *
     * Если после выполнении программы выдаются сообщения об утечках, это
     * означает, что где-то не удалена выделенная память.
     */
    for (int i = 0; i < n; i++)
        delete[] dinamic[i];

    delete[] masavg;

    /**
     * Задание 3.
     */

    /**
     * Задание 3.1. Онлайн-упорядочивание.
     *
     * Напишите фрагмент кода, который вводит N целых чисел с помощью потока
     * ввода в объявленный Вами встроенный одномерный массив, каждый раз
     * упорядочивая полученное значение по возрастанию.
     *
     * Дайте оценку количества сравнений и перестановок при вводе всех чисел
     * относительно N.
     *
     * Постарайтесь, чтобы и сравнений, и перестановок было не больше, чем
     * k*N^2, где k - некоторое число.
     */
    n = 8;
    int cur;
    int *numbers1 = new int[n];
    int *test1 = new int[n]{10, 7, 7, 15, 3, 20, 6, 9};

    for (int i = 0; i < n; i++)
    {
        // std::cin >> cur;
        cur = test1[i];

        int j = i;

        while (j > 0 && numbers1[j - 1] > cur)
        {
            numbers1[j] = numbers1[j - 1];
            j--;
        }
        numbers1[j] = cur;
    }
    delete[] numbers1;
    delete[] test1;
    /**
     * Задание 3.2. Простой поиск.
     *
     * Модифицируйте предыдущее задание следующим образом:очередное значение
     * вводится в массив только при условии, что там еще такого нет (то есть
     * дубли игнорируются).
     */
    int *numbers2 = new int[n];
    int *test2 = new int[n]{10, 7, 10, 8, 3, 8, -16, 133};
    int top = 0;

    for (int i = 0; i < n; i++)
    {
        // std::cin >> cur;
        cur = test2[i];

        int j = top;
        int fl = 0;
        for (int p = 0; p < top; p++)
        {
            if (cur == numbers2[p])
                fl = 1;
        }
        if (!fl)
        {
            while (j > 0 && numbers2[j - 1] > cur)
            {
                numbers2[j] = numbers2[j - 1];
                j--;
            }
            numbers2[j] = cur;
            top++;
        }
    }
    delete[] numbers2;
    delete[] test2;
    /**
     * Задание 4. Сортировка строк.
     *
     * С помощью данной заготовки напишите программу, которая:
     *
     * 1. вводит строки с клавиатуры с помощью cin>>... в объявленный Вами
     *    двухмерный встроенный массив 5*80 элементов типа char; признаком конца
     *    ввода является символ * (то есть строка - "*") или заполнение массива
     *    (больше свободных строк нет);
     * 2. сортирует строки в алфовитном порядке и выводит на экран.
     *
     * Пояснение: крайне не рекомендуется для сортировки сложных объектов
     * физически перемещать их в памяти. Намного эффективнее завести массив
     * указателей на соответствующие строки и перемещать только указатели.
     *
     * Подсказка: для лексиграфического сравнения строк пользуйтесь функцией
     * стандартной библиотеки strcmp(...), заголовочный файл <cstring>.
     */

    if (0)
    {
        /** Определите необходимые значения как константы */

        // STOP_STRING  -  "*"  //признак "прекратить ввод"
        // M  -  80 //максимальный размер одной строки
        // N  -  10 //максимальное количество строк в массиве
        const int N = 10, M = 80;
        const char STOP_STRING = '*';

        /**
         * Объявите двухмерный массив с именем cBuffer типа char и размерностью
         * N*M.
         */
        char cBuffer[N][M] = {};
        /**
         * Объявите массив (с именем cPointers) указателей на строки
         * размерностью N.
         */
        char *cPointers[N] = {};

        /**
         * Цикл ввода строк:
         * 1. выведите приглашение для ввода;
         * 2. пока не введена строка STOP_STRING или не заполнен весь массив;
         */

        int count_string = 0, count_symbol = 0;
        char symbol;
        std::cout << "ВВедите до " << N << " строк до " << M << " символов в каждой \n";
        symbol = std::getchar();
        while (count_string < N && count_symbol < M)
        {
            if (symbol != '\n')
            {
                if (symbol == STOP_STRING && count_symbol > 0)
                {
                    count_string++;
                    break;
                }
                else if (symbol == STOP_STRING && count_symbol == 0)
                {
                    break;
                }
                cBuffer[count_string][count_symbol++] = symbol;
            }
            else
            {
                count_string++;
                count_symbol = 0;
            }
            symbol = std::getchar();
            ;
        }
        for (int nIndex = 0; nIndex < N; nIndex++)
            cPointers[nIndex] = cBuffer[nIndex];

        for (int i = 0; i < count_string; i++)
        {
            std::cout << cPointers[i];
            std::cout << std::endl;
        }
        /** ввод строки в массив cBuffer: */

        /** если введена строка - признак окончания, то выйти из цикла */

        /** Присвойте элементу массива cPointers с индексом nIndex */

        /** указатель на строку с номером nIndex в массиве cBuffer */

        std::cout << "ВВод окончен\n";

        /** Выдать диагностику о том, что прием строк завершен.*/
        bool swap = true;

        while (swap)
        {
            swap = false;
            for (int i = 0; i < count_string - 1; i++)
            {
                if (strcmp(cPointers[i], cPointers[i + 1]) > 0)
                {
                    char *temp = cPointers[i + 1];
                    cPointers[i + 1] = cPointers[i];
                    cPointers[i] = temp;
                    swap = true;
                }
            }
        }

        for (int i = 0; i < count_string; i++)
        {
            std::cout << cPointers[i];
            std::cout << "\n";
        }
        /**
         * Теперь сортируем строки.
         *
         * Необходимо использовать сортировку строк по методу "всплывающего
         * пузырька" в порядке возрастания.
         *
         * На каждой итерации - промежуточная печать отсортированных строк.
         */
    }

        /**
         * Задание 5. Динамические строки.
         *
         * Реализуйте задание №4, используя не встроенные, а динамические массивы
         * (массив?). Так как строки могут быть разной длины, эффективным решением
         * было бы отводить под каждую строку ровно столько байтов, сколько
         * требуется для ее хранения.
         *
         * Реализуйте это задание так, чтобы пользователь мог ввести строку любой
         * длины (которая помещается в память компьютера - читайте: неограниченной
         * длины).
         *
         * При этом необходимые параметры (количество строк) сформируйте с помощью
         * потока ввода.
         */

    {
        const char STOP_STRING = '*';
        int count_string = 0, count_symbol = 0, size = 10;

        int nStringNumber;
        std::cout << "Введите количесвто строк\n";
        std::cin >> nStringNumber;

        char **cBuffer = new char *[nStringNumber];
        char *buf = new char[size];

        /** Цикл ввода строк: */

        char symbol = std::cin.get();
        while (count_string < nStringNumber)
        {
            if (symbol == '\n' || symbol == STOP_STRING)
            {
                if (symbol == STOP_STRING && count_symbol == 0)
                {
                    break;
                }
                char *newBuf = new char[count_symbol + 1];
                for (int i = 0; i < count_symbol; i++)
                    newBuf[i] = buf[i];
                newBuf[count_symbol] = '\0';

                delete[] buf;
                buf = newBuf;

                cBuffer[count_string] = buf;
                size = 10;
                buf = new char[size];

                count_string++;
                count_symbol = 0;
                if (symbol == STOP_STRING)
                    break;
            }
            else
            {
                if (count_symbol >= size)
                {
                    size *= 2;
                    char *newBuf = new char[size];
                    for (int i = 0; i < count_symbol; i++)
                        newBuf[i] = buf[i];
                    delete[] buf;
                    buf = newBuf;
                }

                buf[count_symbol++] = symbol;
            }
            symbol = std::cin.get();
        }


        bool swap = true;
        while (swap)
        {
            swap = false;
            for (int i = 0; i < count_string - 1; i++)
            {
                if (strcmp(cBuffer[i], cBuffer[i + 1]) > 0)
                {
                    char *temp = cBuffer[i + 1];
                    cBuffer[i + 1] = cBuffer[i];
                    cBuffer[i] = temp;
                    swap = true;
                }
            }
        }
        std::cout << "После сортировки: \n";
        for (int i = 0; i < count_string; i++)
        {
            std::cout << cBuffer[i];
            std::cout << "\n";
        }
        /**
         * Цикл сортировки строк по методу "всплывающего пузырька" в порядке
         * возрастания кода первого символа.
         */

        /** Освобождение занятой памяти */
        for (int i = 0; i < count_string; i++)
            delete[] cBuffer[i];
        delete[] buf;
    }

    /**
     * Задание 6. Работа со строками.
     *
     * Реализуйте следующую программу. Пользователь вводит строку (любого
     * размера), после чего пользователю выводится на консоль следующее
     * изображение, где его ввод помещен в "speech bubble":
     *
     *  _____________________________________
     * / Here user input is shown. This line \
     * \ must be at most 40 characters long. /
     *  ------------------------------------
     * 
     *     \
     *      \
     *        /\_/\  (
     *       ( ^.^ ) _)
     *         \"/  (
     *       ( | | )
     *      (__d b__)
     *
     *  При этом длина строки в "облачке" должна быть не более 40 символов, при
     *  этом слова должны переноситься аккуратно. Это означет, что не должно
     *  быть переносов в центре слова (если только это слово не больше 40
     *  символов).
     *
     *  Дизайн облачка и ASCII-арт допустимо поменять по усмотрению.
     *
     *  Подсказка: обратите внимание на конкатенацию строковых литералов в
     *  языке С, это позволит задавать подобные рисунки так, чтобы они
     *  адекватно выглядели в коде.
     */

    /**
     * Задание 7. Сложные указатели.
     *
     * Объявление и использование указателей на многомерные массивы.
     * Проинициализируйте трехмерный массив double dArray[4][3][3] так, как
     * показано на рисунке и напишите фрагмент кода, который меняет местами
     * значения элементов четных и нечетных слоев:
     *
     *  было:                |--------|
     *                     / |4  4  4 |
     *                   |--------| 4 |
     *                 / |3  3  3 | 4 |
     *               |---------|3 |   |
     *             / | 2  2  2 |3 | /
     *            |---------|2 |__|
     *            | 1  1  1 |2 | /
     *            | 1  1  1 |__|
     *            | 1  1  1 | /
     *            |_________|
     *
     *  стало:               |--------|
     *                     / |3  3  3 |
     *                   |--------| 3 |
     *                 / |4  4  4 | 3 |
     *               |---------|4 |   |
     *             / | 1  1  1 |4 | /
     *            |---------|1 |__|
     *            | 2  2  2 |1 | /
     *            | 2  2  2 |__|
     *            | 2  2  2 | /
     *            |_________|
     */

    {
        double dArray[4][3][3] = {};
        for (int x = 0; x < 4; x++)
        {
            for (int y = 0; y < 3; y++)
            {
                for (int z = 0; z < 3; z++)
                {
                    dArray[x][y][z] = x + 1;
                }
            }
        }

        for (int i = 0; i < 4 - 1; i++)
        {
            double (*transfer_cur)[3][3] = &dArray[i];
            double (*transfer_next)[3][3] = &dArray[i+1];

            /**
             * Замечание: НЕ НУЖНО МОДИФИЦИРОВАТЬ ВЫРАЖЕНИЯ СПРАВА ОТ ЗНАКА
             * РАВЕНСТВА!!!
             */

            // ... =  dArray[i];
            // ... =  dArray[i+1];

            /** переставляем местами элементы i-того и i+1-ого слоев */
        }
    }

    /**
     * Задание 7.
     */

    /**
     * Задание 7.1.
     *
     * Объявите двухмерный встроенный массив элементов типа char.
     *
     * Сформируйте значения элементов массива с помощью генератора случайных
     * чисел таким образом, чтобы в массиве были только символы '*' и '_'.
     *
     * В каждой строке "сдвиньте звездочки" в начало строки, например:
     * было - '*' '_' '_' '*' '*' '_' '*' '_' '*' '_'
     * стало: '*' '*' '*' '*' '*' '_' '_' '_' '_' '_'
     * и распечатайте массив по строкам.
     *
     * При этом оцените количество операций, которое требуется для обработки
     * одной строки относительно длины этой строки.
     *
     * Постарайтесь решить эту задачу так, чтобы требовалось не более k*N
     * операций, где N - длина строки, k - некое фиксированное число.
     */

    {
    }

    /**
     * Задание 7.2.
     *
     * Модифицируйте предыдущее задание следующим способом: После заполнения
     * массива с помощью генератора случайных чисел "сдвиньте" звездочки по
     * столбцам вниз и распечатайте результат.
     */

    {
    }

    return 0;
}
