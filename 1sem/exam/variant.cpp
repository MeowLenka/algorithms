#include <iostream>

// Знаковость каких переменных влияет на результат
char c = 0xff;
int n1 = c; 
unsigned int n2 = c; // <-

void f(int, char, double)
{
    std::cout << "hello\n";
}

// Корректный вариант объявления функций
void f(int, char, double = 1.1);         // <-
void f(int = 1, char = 2, double = 1.1); // <-
void f(int = 1, char, double = 1.1);     // Это нарушает правило: если у параметра есть значение по умолчанию, то у всех следующих за ним параметров они тоже должны быть.

// Корректный вариант объявления функций
int f1(); // <-
static char* f2(void); // <-
void double f3(const char*);
int f4(int a, b);
bool f5(int a+5, int b+5);
double f6(5, 6);

// при размещении текста программы в нескольких файлах
// а. компилятор автоматически находит описания свойств внешних по отношению к данному файлу понятий в других файлах проекта
// -> b. компоновщик формирует адресные части внешних по отношению к данному файлу понятий
// -> с. программист должен предоставить компилятору описания всех внешних по отношению к данному файлу понятий
// d. препроцессор автоматически находит описания свойств внешних по отношению к данному файлу понятий в других файлах проекта

// ключевое слово const
// а. предписывает компилятору отвести память под такую переменную в статической памяти
// -> b. запрещает модификацию переменной
// с. предписывает компилятору избегать оптимизаций при действиях с такой переменной

// какого типа p1 и p2
const char *p1, *p2; // указатели на константные символы, оба const char*

// препроцессор -> запускается всегда автоматически перед компиляцией файла

// Передавать параметры по значению имеет смысл в тех случаях, когда
//  -> а. формируется копия большого объекта для того, чтобы функция могла модифицировать копию, не затрагивая оригинал
//  -> b. передаваемый объём данных невелик

char ar[3][5];
char *p1 = ar;      // говно
char **p2 = ar;     // говно
char (*p3)[5] = ar; // <- вот корректно

void f(int &);
int n = 1;
const int *p = &n;
f(n);  // <-корректно
f(*p); // говно
f(1);  // говно

 // при определении массива обязательными составляющими являются:
 // -> а. тип элементов
 // b. все размерности или все младшие размерности при наличии списка инициализаторов
 // -> с. имя

 // инструкция return
 // -> а. используется в том случае, когда функция возвращает значение, но вызывающая функция это значение игнорирует
 // -> b. может быть использована в функции, которая возвращает значение
 // с. используется в том случае, когда функция не возвращает значения

 // Даны объявления int x, y;. Отметьте, какие из следующих выражений являются lvalue
 // (-> а. x) (b. !x) (c. x+y) (d. x++) (-> e. ++x)

 // Для того, чтобы вызывать inline функцию в разных файлах, ее тело следует помещать
 // а. в отдельный файл реализации (срр) согласно правилам структурного программирования
 // -> b. в интерфейсный (h) файл
 // с. в один из тех файлов, где находится вызов

 // ключевое слово inline используется для того чтобы
 // а. обязать компилятор вместо вызова функции подставлять ее тело
 // b. задать компилятору соглашение о вызове функции
 // -> с. рекомендовать компилятору вместо вызова функции подставлять ее тело
 // d. предписать компилятору передавать параметры в регистрах

 // Признаком функции с переменным числом параметров является (-> многоточие ...)

 // чем отличается файл с исходным текстом от единицы компиляции
 // -> а. единица компиляции - это окончательно сформированный текст, с которым поступает на вход компилятора
 // b. это два термина для обозначения одного и того же понятия
 // -> с. в тексте исходного файла возможно используются внешние по отношению к данному файлу понятия

 // отметь корректные выражения
 int a = 1,
     b = 5;
int *p1 = g((a < b) ? a : b); // -> 1
int *p2 = g(a++);             // 2 (нет rvalue)
int *p3 = g(++a);             // -> 3

// для того, чтобы воспользоваться функцией в другой единице компиляции
// -> а. ключевое слово extern необязательно
// b. ее необходимо объявить с ключевым словом static
// с. ее необходимо объявить с ключевым словом extern

// корректен ои следующий фрагмент
int x = 5;
x++;
double x = 1.1;
x++;
// нет, из-за повторного определеня x

// заголовочные файлы могут содержать:
/*a.**/ int w = 1;
/*b.**/ enum NUM
{
    ONE,
    TWO,
    THREE
};
NUM mynum;
/*-> c.**/ enum
{
    ONE,
    TWO,
    THREE
};
/*-> d.**/ enum NUM
{
    ONE,
    TWO,
    THREE
};
/*-> e.**/ const int ar[] = {1, 2, 3};

// Декоративные имена в С++
// -> а. формируются для компоновщика
// -> b. хранятся в объектных модулях
// -> с. формируются компилятором
// d. формируются для программиста

// ссылка
// а. это переменная, в которую копируется содержимое объекта
// -> b. это вообще не переменная, так как компилятор для ссылки память не резервирует
// с. это переменная, которая содержит адрес объекта

// Задана структура
struct X
{
    int n;
    char c;
    char ar[10];
};
X xx = {1, 'A', "Q"};
// Как будут проинициализированы поля структуры?
// -> n = 1; c = 'A'; ar[0] = 'Q' и все остальные элементы массива проинициализированы нулями

// отметить синтаксически верные выражения
int arr[10];
int *p1 = arr; // <-
double *p2 = p1;
int *p3 = &arr[9]; // <-
int n1 = p1 - p3;  // <- ну типо дипсик сказал
int n2 = p3 - p2;

{ // отметить синтаксически верные выражения
    int ar[10];
    int *p1 = ar;     // <-
    int *p2 = p1 + 5; // <-
    int *p3 = p2 - 5; // <-
    int *p4 = p1 + 1.5;
    if (p3 > p1) // <-
    {
    }
}

{ // отметить синтаксически верные выражения
    int ar[10];
    int *p1 = &ar[1]; // <-
    int *p2 = &ar[9]; // <-
    int n1 = p1 - p2; // <-
    int n2 = p1 + p2; // (сложение двух указателей бессмысленно и запрещено)
    if (p1 == p2) // <-
    {
    }
}
// отметить корректные выражения
char ar[3][5];
ar[0] = "qwe";
ar[0][0] = 'a';     // <-
*ar[0] = 'b';       // <-
*(ar[0] + 1) = 'c'; // <-

// декорирование имен используется:
// а. чтобы не допустить определения переменных разного типа с одним и тем же именем
// -> b. для перегрузки имен функций
// с. чтобы можно было определять переменные разного типа с одним и тем же именем

// препроцессор осуществляет: (выберите олин или несколько ответов)
// а. траснляцию текста в двоичный код
// -> b. окончательное формирование текста программы
// c. лексический анализ текста программы
// d. синтаксический анализ текста программы

// отметить корректные варианты:
struct A
{
};
struct B
{
    A *pA;
};

B b = {new A}; // <-

A a;
B b;
*b.pA = a;

A a;
B b;
b.pA = &a; // <-

// Задана структура
struct A
{
    ...
};
// Какой из прототипов функции может соответствовать вызову:
A a;
F(a); // ?????

void F(A &);       // <-
void F(const A &); // <-
void F(A *);
void F(A); // <-

// результат оператора sizeof га 32-разрядно йплатформе
size_t n = sizeof(double (*)(double)); // это тип указатель на функцию, принимающую double и возвращающую double.
// =4

// что это?
int (*f(void))[20];
// -> а. объявление функции, которая возвращает указатель на массив
// b. массив указателей на функции
// что из этого
// c. указатель на функцию

// единица компиляции - это результат работы:
// а, компилятора
// -> b. препроцессора
// с. компоновщика
// d. программиста
{
    // Единица трансляции (единица компиляции) — это исходный файл (.cpp) после обработки препроцессором. То есть это тот окончательный текст, в котором:
    // Все директивы #include заменены на содержимое указанных заголовочных файлов.
    // Все макросы (#define) раскрыты.
    // Удалены комментарии.
    // Выполнена условная компиляция (#ifdef и т.п.).
    // Этот готовый текст уже передаётся на вход компилятору для синтаксического анализа, генерации кода и создания объектного файла.
}

union A
{
    char c;
    char ar[10];
    char *p;
};
size_t n = sizeof(A); // >=10 (не >=15)

// какие выражения синтаксически корректны
{
    char ar1[10] = "abc"; // <-
    char ar2[3] = "abc";
    char ar3[] = {'a', 'b', 'c'}; // <-
    extern char ar4[] = {'a', 'b', 'c'};
    const char ar5[];
}

// какие выражения корректны
int ar1[] = {1, 2, 3}; // <-
extern int ar2[3] = {1, 2, 3};
int ar3 = {1, 2, 3};
int ar4[]; // НЕТ объявление массива без размера и без инициализатора не допускается

// сколько раз выполнтися тело цикла
int n = 5;
while (--n = 0)
{
    ...
} // ни разу

// типы переменных р1 и р2
#define PINT int *
PINT p1, p2;
// р1 - int*; р2 - int

// При генерации кода для тела функции с соглашением по вызову_cdecl компилятор должен:
// а. проверить значения полученных параметров
// -> b. сформировать область стека для локальных переменных данной функции
// с. сохранить контекст вызвавшей функции
// -> d. сгенерировать низкоуровневую команду для возврата управления вызвавшей функции
// -> е. обеспечить восстановление стека перед возвратом из функции

// отметить корректные выражения
{
    int n = 1;
    int *p = &n; //<-
    int &r = n;  // <-
    p = r;       //
    p = &r;      // <-
}

// Задана структура
struct A
{
    int a1 : 2;
    int a2 : 4;
};

// отметить корректные варианты
{
    A a = {1, 2};
    int *p = &a.a1; // ошибка
}
{
    void f(int);
    int main()
    {
        A a = {1, 2};
        f(a.a1); // корректно
    }
}
{
    A a = {1, 2};
    size_t n = sizeof(a.a1);
    // Синтаксически корректно, но результат n будет равен
    // sizeof(int) (обычно 4 байта),
    // а не размеру битового поля в битах.
}

// Сколько байтов компилятор зарезервирует для хранения строкового литерала:
// L ""  //ответ: 2 или 4 байта

struct A
{
    int a;
    // ...
};
// отметить корректные варианты
{ // корректно
    A a1, a2, a3;
    A *ar[] = {&a1, &a2, &a3}; // массив указателей на A
    for (int i = 0; i < sizeof(ar) / sizeof(A *); i++)
    {
        ar[i]->a = i;
    }
}
{             // NO
    A ar[10]; // массив из 10 структур A
    for (int i = 0; i < sizeof(ar); i++)
    {                // sizeof(ar) = 10 * sizeof(A)
        ar[i].a = i; // ОШИБКА: i пробегает до размера массива в байтах, а не до количества элементов
        // Это приведёт к выходу за границы массива.
    }
}
{ // NO
    A a1, a2, a3;
    A *ar[] = {&a1, &a2, &a3}; // массив указателей на A
    for (int i = 0; i < sizeof(ar) / sizeof(A *); i++)
    {
        ar[i].a = i;
    }
}

// память переменной х выделится
{
    static int x = 2; //  в статической памяти
}

// какой тип переменных p1, p2
char *const p1 = "qwe", *p2;
// p1 - char* const; p2 - char*

// корректно?
namespace X
{
    int x;
}
int main()
{
    using namespace X;
    int x; // локальная переменная перекрывает X::x
    x = 1;
} // корректно

// результатом раоты компилятора является:
// a. исполняемый файл // создается компоновщиком (линкером)
// b. окончательно сформированный текст программы // создается препроцессора
// -> c. файл в объектном формате

// какой вариант вставить вместо <***>
namespace X
{
    int x;
}
main()
{
    //***
    x++;
}
// -> a. using X::x;
// b. using namespace X; // нужо X::x++
// c. ничего не нужно вставлять

// инструкция return <выражение>;
// a. может быть использована в функции которая не возвращает значения
// b. может встречаться в функции только один раз
// -> c. может встречаться в функции сколько угодно раз

// применительно к функциям ключево еслово void
// -> а. Функция не принимает параметров
// -> b. функция не возвращает значения
// с. функция является встроенной
// d. функция ничего не делает

// отметить корректные выражения
int *p1 = 0; // <- (нулевой указатель)
int *p2 = 1000;
int *p3 = static_cast<int *>(1000);
int *p4 = reinterpret_cast<int *>(1000); // <- (корректно синтаксически)

// отметить корректные выражения
int n = 1;  // <-
int &r = n; // <-
int &rr = 1;
int *p = &r; // <-
*p = r;      // <-

// int n = 1; отметить корректные выражения
int *p = &n; // <-
int &r = n;  // <-
int a = p;
int b = *r;

// int n = 1; отметить корректные выражения
int &r = n + 1;
int *&r2 = &n;
int &r3 = (++n); // <-
int &r4 = (n++);

// директивы препроцессора
// а. обрабатываются компилятором // Компилятор работает уже с результатом препроцессинга (без директив #).
// -> b. пишутся каждая на отдельной строке или требуется сообщить препроцессору о том, что продолжени
// -> с. начинаются с символа #
// d. требуют окончания символом ;
// (например #include <iostream>)

// нужно проыерить совпадает ли значение младшего байта целой переменной с заданной маской
char maska = <значение>;
int n = <значение>;
int h = 0xff;
if ((n & 0xff) == maska)
    ...
    // корректно, (но мб нужно static_cast<unsigned char>(maska) чтобы точно был кайф)

    // НЕ могут быть перегружены функции, которые
    // -> а. отличаются именами
    // -> b. отличаются типом возвращаемого значения
    // с. отличаются количеством параметров (основной случай перегрузки)
    // -> d. типы параметров которых компилятор не может различить при вызове

    // ИНТЕРЕСНЫЙ ФАКТ: ПЕРЕГРУЗКА: Перегрузка функций (function overloading) позволяет определять несколько функций с одним и тем же именем, но разными параметрами (по типу, количеству или порядку).

    // отметьте корректные варианты перегруженных функций
    {
        int f(int, char);
        void f(int, char);
    }
{
    int f(int, char = 'A');
    int f(int);
}
{ // GOOD
    int f();
    int f(int, char = 'a');
}
{ // GOOD
    int f();
    int f(int, char);
}

// Чтобы воспользоваться функцией, программист
//  а. должен знать внутреннюю реализацию функции
//  -> b. должен знать интерфейс вызова (имя, количество и типы параметров, тип возвращаемого значения)
//  -> с. иметь представление о назначении и результате выполнения функции

// Инструкция break используется:
// а. для повторения текущей итерации цикла
// b. для перехода к следующей итерации цикла
// -> с. для прерывания выполнения цикла
// -> d. для выхода из переключателя (switch)

// в каких случаях компилятор зарезервирует память
extern char *(*x)(double); // объявление
char *(*x)(double);        // <- «указатель на функцию, возвращающую char* и принимающую double»
char *(*x[10])(double);    // <- определение массива из 10 указателей на функцию
char *x(double);           // объявление функции

int x = -1;
int y = 1;
if (x++ == y--)
{
} // принимает значение false

// Использование функций позволяет
// -> а. многократно использовать один и тот же код при выполнении
// -> b. использовать функциональность библиотек
// -> с. улучшить структуру программы
// -> d. добавлять в используемые библиотеки функциональность, не модифицируя сами библиотеки

// динамически выделенная память!
// -> а. обычно в DEBUG-версии заполняется специальными значениями для того, чтобы отследить использование несформированных программистом данны
// b. всегда автоматически инициализируется компилятором нулями
// -> с. может быть проинициализироватна списком инициализаторов

// ... = *("ABC"+2); определите переменную слева от нака равенства
// -> char x объяснение:
// "ABC" — строковый литерал, тип const char[4] (символы 'A','B','C','\0').
// "ABC"+2 — арифметика указателей: смещение на 2 элемента типа char. Указывает на третий символ — 'C'.
// *("ABC"+2) — разыменовываем, получаем значение 'C' (тип char).

// задана структура
struct A
{
    int a1 : 2;
    int a2 : 4;
    int a3 : 8;
    int a4 : 12;
}
// отметьте корректные варианты
{ // GOOD
    A a;
    a.a1 = 1;
    a.a2 = 2;
    a.a3 = 3;
    a.a4 = 4;
}
{ // если бы было pa->a1=1 ... то GOOD
    A *pa = new A;
    a->a1 = 1;
    a->a2 = 2;
    a->a3 = 3;
    a->a4 = 4;
}
{ // GOOD
    A a = {1, 2, 3, 4};
}

// отметьте правильные варианты задания строковых литералов (последовательность символов, заключённая в двойные кавычки)
// -> a. "abc" "qwerty" (смежные строковые литералы автоматически конкатенируются (сливаются) на этапе компиляции. Это эквивалентно: "abcqwerty".)
// -> b. "Labc"
// -> c. "ab\"c"
// d. "qwe"rty"

// сколько раз выполнится цикл
int n = 10;
while (n > 0)
{
    n--;
} // 10 раз

// отметьте корректные варианты
extern const int ar1[]; // <- 1
ar1[0] = 1;             // 2 (он же const!)
int a = 2, b = 3;
const int ar2[] = {a, 0, b}; // <- 3 ()

// bool f(int = 1); отметьте корректные вызовы фунции
bool b = f(6); // <-
if (f())
{
    <выражение>;
}            // <-
f(2) = true; //

// какие переменные компилятор проинициализирует неявно (т.е. нулями)
int a; // <- (глобальная переменная)
namespace Y
{
    int b;
} // <- (статическое хранение)
namespace
{
    int c;
}             // <- (статическое хранение)
static int d; // <- (статическое хранение + глоюально)
int main()
{
    int e;
    static int f; // <- (статическое хранение)
}

// отметьте корректные варианты
int ar[10][20];
int i = 1, j = 2;
ar[i][j] = 1;         // <-
ar[i] = 2;            //
*(*(ar + i) + j) = 3; // <-
*(ar[i] + j) = 4;     // <-

// введен псевдоним: typedef char CH;
// корректно ли: unsigned CH c1; - НЕТ

// функция main может быть
// а. реализована программистом в произвольной форме
// -> b. static
// -> c. inline
// d. extern
// -> е. оформлена только определенным образом
// (ДОП: main не может быть перегружена.)

#define NUM(x, y) x##y
int NUM(a, b);
// какая переменная будет определена пост=редством макроса NUM
int a_b;
int a #b;
int NUM_a_b;
int ab; // <-

char* (*x)[3]; // где переменная х - это...
// а. указатель на функцию, которая возвращает указатель на массив
// -> b. массив из трех указателей char*
// с. указатель на двумерный массив из трех элементов char*
// ПОЯСНЕНИЕ:
// (*x) — x это указатель
// (*x)[3] — указатель на массив из 3 элементов
// char* (*x)[3]; — элементы этого массива имеют тип char* 


// отметьте корректые выражения
char ar[3][5][7];
char* p1 = ar[1][1][1]; // 
char* p2 = ar[1][1]; // <-
char* p3 = ar[1]; // 
char* p4 = ar; //

int n  = 1;
const int m = 2;
extern const int k;
const int h;

// корректна ли ситуация: ДА
// файл 1.cpp: static int x;
// файл 2.cpp: static double x;

char c = 'a';
const char* p1 = &c; // <- (указатель на const char, через p1 нельзя изменить с)
*p1 = 'b'; // 
char* p2 = p1; // 

//	char* const p = &c; - константный указатель  

int a = 5;
if (1/a > 0){} // FALSE

void f1(int);
void f2(int);
// выбрать корректные выражения
void (*x[10])(int)={f1, f2}; // <-
void (*x[])(int); 
void (*x[])(int) = {f1, f2}; // <-
void (*x)(int) = f1; // <- (неявное преобразование в указатель: f1 -> &f1)

// отметить корректные выражения
const char c = 'q';
char* p1 = &c; // 
char*  const p2 = &c; //
const char* p3 = &c; // <-
char const * const p4 = &c; // <-

// отметить корректные выражения
int n = 1;
void* p = &n; // <-
size_t n1 = sizeof(p); // <-
size_t n1 = sizeof(*p); // 
// если бы был sizeof(*(static_cast<int*>(p))) или sizeof(*(int*)p)
// sizeof(1); - корректно ( ИНТЕРЕСНЫЙ ФАКТ) = sizeof(int)

// в реализации рекурсивной функции
// а. программисту следует минимизировать использование локальных переменных
// b. программист не обязан явно предусмотреть выход из рекурсии, так как это сделост компилятор при переполнении стека
// -> с. программист должен предусмотреть выход из рекурсии

// отметьте синтаксически корректные вызовы функции
void f(const char*, int, ...);
f("ABC", 1); // <-
f("ABC", 1, "nm", 1.1); // <-
int n = f("ABC", 1, 2, 3); //
int n = f("ABC"); //

//Для приведения void*-указателя к требуемому типу
// -> а. возможно использовать оператор reinterpret_cast
// -> b. возможно использовать оператор static_cast
// с. компилятор осуществляет такие преобразования неявно
// ИНТЕРЕСНО:
// static_cast выполняет логически допустимые преобразования с проверками на этапе компиляции, 
// а reinterpret_cast делает грубую переинтерпретацию битов без проверок.

// сколько байтов компилятор зарезервирует 
// для хранения строкового литерала "A\nB"
// 4 'A', '\n', 'B', '\0'

// char* x; ...=&x;
// вместо ... - char** y

// отметить корректные выражения
const char* x = "ABC"; // <-
const char y[] = "ABC"; // <-
x[1] = 'W'; // (т к const)
char c2 = y[1]; // <-


// clang++ variant.cpp  -o program && ./program
