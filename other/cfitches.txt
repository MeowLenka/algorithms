printf("%3d %6d\n", fahr, celsius); // чтобы в каждой 
строке первое число печатать в поле из трех позиций, а второе — из шести.
 40      4
 60     15
 80     26
100     37
%6.2f — печать числа с плавающей точкой и двумя цифрами после десятичной точки в поле из шести
позиций.
Кроме того, printf допускает следующие спецификаторы: %o для восьмеричного числа; %х для
шестнадцатеричного числа; %с для символа; %s для строки символов и %% для самого %.

EOF — целая константа, определенная в <stdio.h>.(аббревиатура от end of file — конец файла)

Символ, заключенный в одиночные кавычки, представляет собой целое значение, 
равное коду этого символа (в кодировке, принятой на данной машине). 
Это так называемая символьная константа.

Если константа начинается с нуля, то она представлена в восьмеричном виде, если с 0х или с 0Х, то — в
шестнадцатеричном.

Полный набор эскейп-последовательностей таков:
\а сигнал-звонок
\\ обратная наклонная черта
\b возврат-на-шаг (забой)
\? знак вопроса
\f перевод-страницы
\’ одиночная кавычка
\n новая-строка
\” двойная кавычка
\r возврат-каретки
\ooo восьмеричный код
\t горизонтальная-табуляция
\xhh шестнадцатеричный код
\v вертикальная-табуляция

Символьная константа '\0' — это символ с нулевым значением, так называемый символ null. Вместо
просто 0 часто используют запись '\0', чтобы подчеркнуть символьную природу выражения, хотя и в том и
другом случае запись обозначает нуль.

Функция strlen и некоторые другие, применяемые к строкам, описаны в стандартном заголовочном файле
<string.h>. (вычисляет длину строки)

Во внутреннем представлении строки в конце обязательно присутствует нулевой символ '\0', 
поэтому памяти для строки требуется на один байт больше,
чем число символов, расположенных между двойными кавычками.

enum boolean { NO, YES }; — константа перечисления.

int numbers[4] {1,2,3,4}; // перебор массива 
for(int n : numbers)
    {std::cout << n << std::endl;}
//Если нам неизвестен тип объектов в массиве, то мы можем использовать спецификатор auto для определения типа:
for(auto n : numbers)

Массив = const адрес + область памяти
int A[5] = {1, 2, 3, 4, 5};
A[i] = *(A+i);
&A[i] = A+i;
&*p = p;
p - q ( где p и q - указатели, получаем количесвто ячеек памяти между ними)


Here user input is shown. This line must be at most 40 characters long.